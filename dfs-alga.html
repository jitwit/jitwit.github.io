<html><head><style>
.hs-keyword { color: sienna; }
.hs-conid { color: teal; } 
.hs-conop { color: teal; } 
.hs-keyglyph { color: steelblue; }
.hs-layout { color: steelblue; }
.hs-definition { color: darkslateblue; }
.hs-varid { color: darkslateblue; }
.hs-varop { color: crimson; }
               </style><meta charset='UTF-8'/><title>DFS Alga</title></head><body><h2>Expressing graph searches in haskell</h2><p><section>Recently, I helped contribute to <a href='https://github.com/snowleopard/alga'>alga</a>, a fun haskell library for working with graphs developped by
Andrey Mokhov. My first contribution implemented breadth first
search. The second took ideas from the first to improve the existing
implementations of depth first search and topological sort. This post
describes the implementations and how haskell lends itself well to the
expression of these classic algorithms.</section></p><h3>Backround on alga</h3><p><section>With alga, graphs are built using a handful of building blocks,
after which they may be instantiated to a suitable structure for
further processing. Here is the core data type:<pre><span class='hs-keyword'>data</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Vertex</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Overlay</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Connect</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span></pre><tt>Empty</tt> denotes an empty graph and <tt>Vertex a</tt> a graph with one vertex <tt>a</tt>. More complex graphs are constructed by combining
smaller ones in two ways. <tt>Overlay g h</tt> forms a graph whose vertex and edges sets are the unions
of <tt>g</tt>'s and <tt>h</tt>'s. <tt>Connect g h</tt> is similar, but additionally includes an edge going from each vertex
    of <tt>g</tt> to each vertex of <tt>h</tt>. Given a graph of type <tt>Graph a</tt>, we are ready to process it. Conversion to a given structure is
usually done by the appropriate fold over the core data type. More
complete and lucid introductions to alga in its design may be found in
a series of <a href='https://github.com/snowleopard/alga#blog-posts'>blog posts</a> or if you prefer video, <a href='https://www.youtube.com/watch?v=EdQGLewU-8k'>this talk</a>.</section></p><h3>Depth First Search</h3>Previously, alga wrapped the graph type from <a href='http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html'>Data.Graph</a> to take advantage of existing the dfs implementation.<pre>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalState</span> <span class='hs-layout'>(</span><span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-conid'>IntSet.empty</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
    <span class='hs-conid'>True</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
    <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
  <span class='hs-varid'>explore</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
  <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toList</span> <span class='hs-layout'>(</span><span class='hs-varid'>postIntSet</span> <span class='hs-varid'>v</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>new</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-conid'>IntSet.member</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>when</span> <span class='hs-varid'>new</span> <span class='hs-varop'>$</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntSet.insert</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>return</span> <span class='hs-varid'>new</span>
     </pre><h3>Topological Sort</h3><pre>
<span class='hs-keyword'>type</span> <span class='hs-conid'>Cycle</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonEmpty</span>
<span class='hs-keyword'>data</span> <span class='hs-conid'>NodeState</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Exited</span>
<span class='hs-keyword'>data</span> <span class='hs-conid'>S</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>S</span> <span class='hs-layout'>{</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>Int</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>entry</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>NodeState</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>order</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>

<span class='hs-definition'>topSort'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>MonadState</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>MonadCont</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cycle</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>topSort'</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>callCC</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>cyclic</span> <span class='hs-keyglyph'>-&gt;</span>
  <span class='hs-keyword'>do</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>vertices</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.toDescList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>adjacencyIntMap</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>adjacent</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toDescList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>postIntSet</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>dfsRoot</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nodeState</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enterRoot</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>x</span>
           <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
         <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span>
                   <span class='hs-varid'>nodeState</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
                     <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enter</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>y</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cyclic</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>.</span> <span class='hs-varid'>retrace</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>=&lt;&lt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>parent</span>
     <span class='hs-varid'>forM_</span> <span class='hs-varid'>vertices</span> <span class='hs-varid'>dfsRoot</span>
     <span class='hs-conid'>Right</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>order</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>nodeState</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.lookup</span> <span class='hs-varid'>v</span> <span class='hs-varop'>.</span> <span class='hs-varid'>entry</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>enter</span> <span class='hs-varid'>u</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-varid'>u</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
                                          <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
                                          <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>enterRoot</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>exit</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.alter</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>leave</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
      <span class='hs-keyword'>where</span> <span class='hs-varid'>leave</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
              <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exited</span>
              <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"Internal error: dfs search order violated"</span>
    <span class='hs-varid'>retrace</span> <span class='hs-varid'>curr</span> <span class='hs-varid'>head</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
      <span class='hs-varid'>aux</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>head</span> <span class='hs-varop'>==</span> <span class='hs-varid'>curr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span>
        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>parent</span> <span class='hs-conid'>IntMap</span><span class='hs-varop'>.!</span> <span class='hs-varid'>curr</span> <span class='hs-varop'>&lt;|</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
              </pre></body></html>