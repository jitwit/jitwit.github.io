<html><head><link rel='stylesheet' type='text/css' href='css/style.css'/><meta charset='UTF-8'/><title>DFS Alga</title></head><body><h1>Graph searches in alga</h1><p><section>Recently, I helped contribute to <a href='https://github.com/snowleopard/alga'>alga</a>, a haskell library for working with graphs developed by Andrey
Mokhov. My first contribution implemented breadth first search. The
second took ideas from the first to improve the existing
implementations of depth first search and topological sort. This post
describes the implementations and illustrates how these classic
algorithms may be expressed in haskell. I'll also present evidence
that the implementations are effective in the form of criterion
benchmarks. For now it suffices to know that the main representation
alga uses for directed graphs is adjacency maps in the form of <tt>Map a (Set a)</tt> or <tt>IntMap IntSet</tt>.</section></p><h2>Depth First Search</h2><p><section>The goal is to produce a forest of vertices by traversing a
graph given a list of vertices to explore. It's a graph traversal when
each vertex is expanded at most once and it's depth first when the
tree from the head of the list is fully explored before considering
the rest. State is used to keep track of the vertices that we have
already been explored. Here is the complete implementation (currently)
found in alga:<pre>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalState</span> <span class='hs-layout'>(</span><span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-conid'>IntSet.empty</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
    <span class='hs-conid'>True</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
    <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
  <span class='hs-varid'>explore</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
  <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toList</span> <span class='hs-layout'>(</span><span class='hs-varid'>postIntSet</span> <span class='hs-varid'>v</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>new</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-conid'>IntSet.member</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>when</span> <span class='hs-varid'>new</span> <span class='hs-varop'>$</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntSet.insert</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>return</span> <span class='hs-varid'>new</span></pre>Two mutually recursive functions drive the computation, <tt>explore</tt> and <tt>walk</tt> . <tt>explore</tt> takes a list of vertices and checks one by one if the next
vertex is unexplored and if so, passes it to <tt>walk</tt>. <tt>walk</tt> builds a tree starting from its argument by exploring its
neighboring vertices. As such, the leap from descriptive specification
to concise implementation is pleasantly direct.</section></p><h2>Breadth First Search</h2><p><section>The goal is to produce a forest of vertices by traversing a
graph given a list of vertices to explore. It's a graph traversal when
each vertex is expanded at most once and it's depth first when the
tree from the head of the list is fully explored before considering
the rest. State is used to keep track of the vertices that we have
already been explored. Here is the complete implementation (currently)
found in alga:<pre>
<span class='hs-definition'>bfsForestFrom'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>bfsForestFrom'</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalState</span> <span class='hs-layout'>(</span><span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-conid'>IntSet.empty</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
    <span class='hs-conid'>True</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>unfoldTreeM_BF</span> <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
    <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
  <span class='hs-varid'>explore</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
  <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>adjacentM</span> <span class='hs-varid'>v</span>
  <span class='hs-varid'>adjacentM</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterM</span> <span class='hs-varid'>discovered</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntSet.toList</span> <span class='hs-layout'>(</span><span class='hs-varid'>postIntSet</span> <span class='hs-varid'>v</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>new</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-conid'>IntSet.member</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>when</span> <span class='hs-varid'>new</span> <span class='hs-varop'>$</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntSet.insert</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>return</span> <span class='hs-varid'>new</span>
</pre>Two mutually recursive functions drive the computation, <tt>explore</tt> and <tt>walk</tt> . <tt>explore</tt> takes a list of vertices and checks one by one if the next
vertex is unexplored and if so, passes it to <tt>walk</tt>. <tt>walk</tt> builds a tree starting from its argument by exploring the
neighboring vertices. As such, the leap from descriptive specification
to concise implementation is pleasantly direct.</section></p><h2>Topological Sort</h2><p><section>Given a directed graph, we return a valid topological ordering
of the vertices if it is acyclic, or we present a cycle otherwise. In
the case that the graph is acyclic, we produce the lexicographically
smallest such ordering (addressing an old <a href='https://github.com/snowleopard/alga/issues/2'>issue</a>). The increased demands, relative to dfs, are reflected in
various ways in the implementation; more state is threaded, a hairier
monad is requested, and the compactness of dfs is gone. It's less
concise, but more interesting.</section></p><h3>Implementation</h3><pre>
<span class='hs-definition'>topSort'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>MonadState</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>MonadCont</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cycle</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>topSort'</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>callCC</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>cyclic</span> <span class='hs-keyglyph'>-&gt;</span>
  <span class='hs-keyword'>do</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>vertices</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.toDescList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>adjacencyIntMap</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>adjacent</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toDescList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>postIntSet</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>dfsRoot</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nodeState</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enterRoot</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>x</span>
           <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
         <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span>
                   <span class='hs-varid'>nodeState</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
                     <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enter</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>y</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cyclic</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>.</span> <span class='hs-varid'>retrace</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>=&lt;&lt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>parent</span>
     <span class='hs-varid'>forM_</span> <span class='hs-varid'>vertices</span> <span class='hs-varid'>dfsRoot</span>
     <span class='hs-conid'>Right</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>order</span></pre><p><section>A topological ordering can be computed by sorting the vertices
by exit time during depth first search. To ensure the
lexicographically smallest such ordering, we procrastinate exploring
smaller vertices as long as possible: the <tt>vertices</tt> are considered in descending order and <tt>adjacent v</tt> is here defined as <tt>toDescList $ postIntSet v g</tt>.</section></p><p><section>The search is characterized by working over state held in a record of type <tt>S</tt> and by the ability to report a cycle. Whereas the dfs
implementation worked over <tt>State IntSet a</tt> the monad here is <tt>(MonadState S m, MonadCont m) =&gt; m a</tt>. The schemer in me was pleased to spot a decent opportunity for <tt>callCC</tt>. When a cycle is discovered, the computation terminates
immediately and the wrapping/unwarpping of some part of the
computation in <tt>Either</tt> is postponed until the very end.</section></p><p><section>The cycle reconstruction function is called when a back-edge is
encountered during the sort. It cons's parents to the cycle until the
ancestor that was Entered but not Exited is reached: <pre><span class='hs-keyword'>type</span> <span class='hs-conid'>Cycle</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonEmpty</span>

<span class='hs-definition'>retrace</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IntMap</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cycle</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>retrace</span> <span class='hs-varid'>curr</span> <span class='hs-varid'>head</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>aux</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>head</span> <span class='hs-varop'>==</span> <span class='hs-varid'>curr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span>
    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>parent</span> <span class='hs-conid'>IntMap</span><span class='hs-varop'>.!</span> <span class='hs-varid'>curr</span> <span class='hs-varop'>&lt;|</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span></pre>The only notable aspect is the type for cycles, which was
informed by pesky compiler warnings and advice from Andrey Mokhov
about how to best get rid of them. He suggested that the way to avoid
incomplete pattern warnings was to find a better data structure--one
that couldn't represent impossible state. <tt>NonEmpty</tt> it is!</section></p><h3>Other Details</h3><p><section>The information here is uninteresting, but included for
thoroughness. Here are internal search state types:<pre>
<span class='hs-keyword'>data</span> <span class='hs-conid'>NodeState</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Exited</span>

<span class='hs-keyword'>data</span> <span class='hs-conid'>S</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>S</span> <span class='hs-layout'>{</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>Int</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>entry</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>NodeState</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>order</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span></pre>The state is represented as a record with three parts: parent
pointers stored in an <tt>IntMap Int</tt>, node states as <tt>Entered</tt> or <tt>Exited</tt>, and a list of vertices ordered by exit time (the eventual
topological ordering). The interface to this state includes:<ul><li><tt>nodeState</tt> to query if a node is unvisited, being processed, or
exited. The result of the query can be <tt>Nothing</tt>, <tt>Just Entered</tt>, or <tt>Just Exited</tt> corresponding to the colors White, Gray, and Black in classic
algorithms books.</li><li><tt>enter</tt> is called when visiting a vertex. The parent vertex and the
node state are updated.</li><li><tt>enterRoot</tt> to explore a new component of the search tree. There is no
parent to enter, only the entry table is updated.</li><li><tt>exit</tt> called when the given vertex's descendents have been processed.</li></ul><pre>
<span class='hs-definition'>nodeState</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.lookup</span> <span class='hs-varid'>v</span> <span class='hs-varop'>.</span> <span class='hs-varid'>entry</span><span class='hs-layout'>)</span>

<span class='hs-definition'>enterRoot</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>

<span class='hs-definition'>enter</span> <span class='hs-varid'>u</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-varid'>u</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
                                      <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
                                      <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>

<span class='hs-definition'>exit</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.alter</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>leave</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span> <span class='hs-varid'>leave</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
          <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exited</span>
          <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"Internal error: dfs search order violated"</span></pre>Vertices are visited once and exited once. An error is thrown when
this isn't the case (never).</section></p><h2>Alga Background</h2><h3>Core Idea</h3><p><section>Alga deals with the construction and manipulation of
graphs. A (di-) graph is some object with a set of vertices and a set
edges, (ordered) pairs of vertices. The main way that alga expresses
this is with the following data type: <pre><span class='hs-keyword'>data</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Vertex</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Overlay</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Connect</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span></pre>Vertices are drawn from elements of some type <tt>a</tt> and wrapped by the <tt>Vertex</tt> constructor. <tt>Overlay g h</tt> is the graph whose vertex and edge sets are the unions of <tt>g</tt>'s and <tt>h</tt>'s. <tt>Connect g h</tt> is the graph whose vertex and edge sets contain those from
overlay, as well as an edge for every vertex of <tt>g</tt> to every vertex of <tt>h</tt> . This construction is now visibly algebraic in the sense that
there are two closed operations for building graphs from other
graphs, <tt>Overlay</tt> and <tt>Connect</tt>, which in fact satisfy axioms analogous to <tt>+</tt> and <tt>*</tt>. In fact alga provides a cute <tt> Num </tt> instance, so that expressions like <tt> 1*2 </tt> can be used to construct an edge from 1 to 2 (note, * is
overlay). It's also cute in the sense that it's not lawful. <tt> Num </tt> is usually intended for Rings, where the identities for + and *
are distinct. Here, both overlay and connect have <tt>Empty</tt> as identity.</section></p><p><section>The <tt>Graph</tt> data type can be viewed as a DSL for graph construction. Alga
also defines an encoding for this construction as a type class <tt>Graph g</tt>, which requires analogues for the type constructors of the data
type as functions <tt>empty, vertex, overlay, connect</tt>. Another type class <tt>ToGraph</tt> is for types that can be embedded in the <tt>Graph</tt> data type by <tt>toGraph :: ToGraph g =&gt; g -&gt; Graph (ToVertex g)</tt>. These graph expressions may in turn be &quot;interpreted&quot; in fold
over the <tt>Graph</tt> encoding, <tt>foldg :: ToGraph g =&gt; r -&gt; (ToVertex g -&gt; r) -&gt; (r -&gt; r -&gt; r) -&gt; (r -&gt; r -&gt; r) -&gt; g -&gt; r</tt>. </section></p><p><section>Working with <tt>ToGraph</tt> is powerful, since algebraic graphs can converted between
representations, allowing code sharing between possibly disparate
types. In other words, the following is enough to run the graph
searches from above on any <tt>ToGraph g</tt> type: </section></p><pre>
<span class='hs-keyword'>newtype</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-layout'>{</span> <span class='hs-varid'>adjacencyMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Map</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>

<span class='hs-definition'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span> 
<span class='hs-definition'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-conid'>Map.empty</span>

<span class='hs-definition'>vertex</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>vertex</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Map.singleton</span> <span class='hs-varid'>x</span> <span class='hs-conid'>Set.empty</span>

<span class='hs-definition'>overlay</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>overlay</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Map.unionWith</span> <span class='hs-conid'>Set.union</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>

<span class='hs-definition'>connect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>connect</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Map.unionsWith</span> <span class='hs-conid'>Set.union</span>
    <span class='hs-keyglyph'>[</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-conid'>Map.fromSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Map.keysSet</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Map.keysSet</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>

<span class='hs-definition'>toAdjacencyMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>ToVertex</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>toAdjacencyMap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldg</span> <span class='hs-varid'>empty</span> <span class='hs-varid'>vertex</span> <span class='hs-varid'>overlay</span> <span class='hs-varid'>connect</span></pre><h3>More Information</h3><p><section>There is much more to alga. The above hopefully gives an idea of
the library's algebra and its approach to graphs. Alga also provides
means for working with undirected graphs, relations, acyclic graphs,
bipartite graphs, and so on.</section></p><h3>Previously</h3><p><section>The previous implementations in fact used <tt>ToGraph g</tt> to convert between representations to use the the <a href='http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html'>Data.Graph</a> module, given a conversion from adjacency maps to the <tt>Graph :: Array Int [Int]</tt> representation:<pre>
<span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Algebra.Graph.AdjacencyMap</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>AM</span>
<span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Graph</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>KL</span>

<span class='hs-definition'>fromAdjacencyMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>GraphKL</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>fromAdjacencyMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM.AM</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GraphKL</span>
    <span class='hs-layout'>{</span> <span class='hs-varid'>toGraphKL</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span>
    <span class='hs-layout'>,</span> <span class='hs-varid'>fromVertexKL</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>u</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>r</span> <span class='hs-varid'>u</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span>
    <span class='hs-layout'>,</span> <span class='hs-varid'>toVertexKL</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span> <span class='hs-layout'>}</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-layout'>(</span><span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>KL.graphFromEdges</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-conid'>()</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-conid'>Set.toAscList</span> <span class='hs-varid'>us</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>us</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>Map.toAscList</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>]</span></pre> The pipeline went something like: <ul><li><tt>toAdjacencyMap . toGraph :: g -&gt; AdjacencyMap (ToVertex g)</tt></li><li><tt>fromAdjacencyMap :: AdjacencyMap (ToVertex g) -&gt; GraphKL (ToVertex g)</tt></li><li><tt>map (fmap fromVertexKL) . Data.Graph.dff . toGraphKL :: Data.Graph -&gt; Forest (ToVertex g)</tt></li></ul></section></p><p><section><tt>Data.Graph</tt> provides good performance for the functions it does export,
since it works on memory-compact adjacency maps represented as <tt>Array Int [Int]</tt> and is a mature module. Unfortunately, the array-based
representation does not play well with alga's algebraic graphs, so
it's not clear how reduce the number of conversions.</section></p><p><section>For more information about alga, its design, and its laws, I'd
suggest checking out any of the following:  a series of <a href='https://github.com/snowleopard/alga#blog-posts'>blog posts</a>, <a href='https://www.youtube.com/watch?v=EdQGLewU-8k'>this talk</a>, <a href='https://eprint.ncl.ac.uk/file_store/production/239461/EF82F5FE-66E3-4F64-A1AC-A366D1961738.pdf'>this paper</a> or the <a href='http://hackage.haskell.org/package/algebraic-graphs'>documentation</a>.</section></p><h2>Benchmarks</h2>Here are links to various benchmarks done with criterion:<ul><li><a href='criterion/depth-first-bench.html'>depth-first-bench</a></li><li><a href='criterion/topological-bench.html'>topological-bench</a></li><li><a href='criterion/words-graph.html'>words-graph</a></li><li><a href='criterion/scc-bench.html'>scc-bench</a></li><li><a href='criterion/breadth-first-bench.html'>breadth-first-bench</a></li><li><a href='criterion/misc-graphs.html'>misc-graphs</a></li><li><a href='criterion/dag-topological-bench.html'>dag-topological-bench</a></li></ul><p><section>Benchmarks are run after construction, to focus on query
performance. fgl and containers don't seem to have easy support for
working with graphs whose vertices are not type Int, so most of the
benchmarks compare them against alga's AdjacencyIntMaps. Many of the
graphs are borrowed from <a href='https://github.com/haskell-perf/graphs'>haskell-perf/graphs.</a></section></p><p><section><table><caption>Average relative performance over haskell-perf graphs</caption><tr><th></th><th align='right'>new-alga</th><th align='right'>old-alga</th><th align='right'>kl</th><th align='right'>fgl</th></tr><tr><td align='left'>breadth-first</td><td align='right'>1.00</td><td align='right'>n/a</td><td align='right'>n/a</td><td align='right'>10.20</td></tr><tr><td align='left'>dag-topological</td><td align='right'>1.00</td><td align='right'>2.94</td><td align='right'>0.50</td><td align='right'>4.78</td></tr><tr><td align='left'>depth-first</td><td align='right'>1.00</td><td align='right'>5.82</td><td align='right'>0.95</td><td align='right'>8.74</td></tr><tr><td align='left'>scc</td><td align='right'>1.00</td><td align='right'>2.82</td><td align='right'>n/a</td><td align='right'>12.91</td></tr><tr><td align='left'>topological</td><td align='right'>1.00</td><td align='right'>6489.81</td><td align='right'>1290.92</td><td align='right'>87964.65</td></tr></table><br>There are two benchmarks for topological sort,
since the graphs have cycles. At first blush, it seems like nonsense
to compare implementations because the new one short circuits once it
finds a cycle. On the other hand, the old alga implementation would
first run <tt>topSort</tt> from Data.Graph and subsequently <tt>guard $ isTopSortOf result</tt>. Thus, the ~6500 fold improvement over the old implementation
is a semi-legitimate comparison on directed cyclic graphs. On DAGs,
the improvement is ~3 fold. The graphs are made acyclic by removing
self-loops and reversing edges so that <tt>(x,y) -&gt; (min x y, max x y)</tt>. The vertices are then randomly permuted since the new topSort
implementation considers them in sorted order.<table><caption>Sizes of the haskell-perf/graphs</caption><quote><tr><th><b><tt>G</tt></b></th><th align='right'><b><tt>|E|</tt></b></th><th align='right'><b><tt>|V|</tt></b></th></tr></quote><tr><td align='left'>n1</td><td align='right'>21</td><td align='right'>15</td></tr><tr><td align='left'>n2</td><td align='right'>404</td><td align='right'>87</td></tr><tr><td align='left'>n3</td><td align='right'>3228</td><td align='right'>349</td></tr><tr><td align='left'>n4</td><td align='right'>26703</td><td align='right'>1628</td></tr><tr><td align='left'>n5</td><td align='right'>57949</td><td align='right'>3487</td></tr><tr><td align='left'>nodes4000</td><td align='right'>40000</td><td align='right'>4000</td></tr><tr><td align='left'>nodes7000</td><td align='right'>70000</td><td align='right'>7000</td></tr><tr><td align='left'>nodes8000</td><td align='right'>80000</td><td align='right'>8000</td></tr><tr><td align='left'>nodes10000</td><td align='right'>100000</td><td align='right'>10000</td></tr></table><p><section>The source code for the benchmarks can be viewed at <a href='https://github.com/jitwit/bench-alga/blob/master/report.hs'>bench-alga</a></section></p></section></p></body><footer>updated: 18/9/2019</footer></html>