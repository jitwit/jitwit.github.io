<html><head><link rel='stylesheet' type='text/css' href='css/style.css'/><link rel='stylesheet' type='text/css' href='css/haskell.css'/><meta charset='UTF-8'/><title>DFS Alga</title></head><body><h1>Expressing graph searches in haskell</h1><p><section>Recently, I helped contribute to <a href='https://github.com/snowleopard/alga'>alga</a>, a very cool haskell library for working with graphs developed
by Andrey Mokhov. My first contribution implemented breadth first
search. The second took ideas from the first to improve the existing
implementations of depth first search and topological sort. This post
describes the implementations and illustrates how haskell lends itself
well to the expression of these classic algorithms.</section></p><p><section>The first few sections dive in to the
implementations. Background information about alga will follow
containing pointers to better introductions. The final section
discusses the previous implementations and includes benchmarks.</section></p><p><section>For now it suffices to know that one of the main representations
alga uses for directed graphs is adjacency maps using data structures
from the containers package, <tt>Map a (Set a)</tt> for graphs with vertices that have <tt>Ord a</tt> instances or <tt>IntMap IntSet</tt> for ones with <tt>Int</tt> vertices. These are the representations the implementations are concerned with.</section></p><h2>Depth First Search</h2><p><section>Depth first search is the simplest of the
implementations. Algorithmically, it's not very different from breadth
first search, but is expressed more readily in haskell due to the
first class status of linked lists and the representation of forests
as free lists. </section></p><p><section>Here is the whole implementation (currently) found in alga:<pre>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalState</span> <span class='hs-layout'>(</span><span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-conid'>IntSet.empty</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
    <span class='hs-conid'>True</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
    <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
  <span class='hs-varid'>explore</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
  <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toList</span> <span class='hs-layout'>(</span><span class='hs-varid'>postIntSet</span> <span class='hs-varid'>v</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>new</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-conid'>IntSet.member</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>when</span> <span class='hs-varid'>new</span> <span class='hs-varop'>$</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntSet.insert</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>return</span> <span class='hs-varid'>new</span></pre></section></p><p><section>A depth first search forest is produced given a list of vertices
to search. Two mutually recursive functions drive the computation, <tt>explore</tt> which checks that the next vertex is unexplored and if so passes it to <tt>walk</tt>. <tt>walk</tt> builds a tree from its argument, passing neighboring vertices back to <tt>explore.</tt> To this end, the necessary state is keeping track of which
vertices have been visited, nothing else. A bottom-up description:<ul><li><tt>adjacent v</tt> exists because it's more pleasant to read than <tt>IntSet.toList (postIntSet v g)</tt>.</li><li><tt>discovered v</tt> reports if the vertex has been discovered and marks it as
such if not.</li><li><tt>walk v</tt> includes the tree from <tt>v</tt> in the forest by exploring <tt>v</tt>'s neighbors.</li><li><tt>explore vs</tt> builds a forest from all undiscovered vertices in <tt>vs</tt>.</li><li><tt>evalState (explore vs) IntSet.empty</tt> computes the forest from <tt>vs</tt>. The venerable state monad is used to thread the set of
discovered vertices through the computation, driven by the mutually
recursive <tt>walk</tt> and <tt>expore</tt>.</li></ul></section></p><p><section><tt>dfsForestFrom'</tt> has the tick  because it is a function internal to the module. The following
three functions are the ones actually exported, matching the original
API from <tt>Data.Graph</tt>:<pre>
<span class='hs-definition'>dfsForest</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForest</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfsForestFrom'</span> <span class='hs-layout'>(</span><span class='hs-varid'>vertexList</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-varid'>g</span>

<span class='hs-definition'>dfsForestFrom</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForestFrom</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfsForestFrom'</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>vs</span><span class='hs-layout'>,</span> <span class='hs-varid'>hasVertex</span> <span class='hs-varid'>v</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>]</span> <span class='hs-varid'>g</span>

<span class='hs-definition'>dfs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>dfs</span> <span class='hs-varid'>vs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfsForestFrom</span> <span class='hs-varid'>vs</span> <span class='hs-varop'>&gt;=&gt;</span> <span class='hs-varid'>flatten</span></pre></section></p><h2>Topological Sort</h2><p><section>The goals for implementing topological sort are loftier than for
dfs. Given a graph, we return either a valid topological ordering of
the vertices or a cycle. If there the graph is acyclic, we want to
produce the lexicographically smallest such ordering (addressing an
old <a href='https://github.com/snowleopard/alga/issues/2'>issue</a>). These increased demands are
reflected in various ways in the implementation; more state is
threaded, a hairier monad is requested, and the compactness of dfs is
gone. All in all, it's more interesting.</section></p><h3>State</h3>In order to produce a cycle, we need to keep track of parent
pointers, as well as if a vertex has been fully processed, or if its
descendents are currently being expanded. Also, root vertices don't
have parents, so their state must be entered differently. The state
representation used is then:<pre>
<span class='hs-keyword'>data</span> <span class='hs-conid'>NodeState</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Exited</span>
<span class='hs-keyword'>data</span> <span class='hs-conid'>S</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>S</span> <span class='hs-layout'>{</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>Int</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>entry</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>NodeState</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>order</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>

<span class='hs-comment'>-- state query/manipulation</span>
<span class='hs-definition'>nodeState</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.lookup</span> <span class='hs-varid'>v</span> <span class='hs-varop'>.</span> <span class='hs-varid'>entry</span><span class='hs-layout'>)</span>
<span class='hs-definition'>enterRoot</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>
<span class='hs-definition'>enter</span> <span class='hs-varid'>u</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-varid'>u</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
                                      <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
                                      <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>
<span class='hs-definition'>exit</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.alter</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>leave</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span> <span class='hs-varid'>leave</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
          <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exited</span>
          <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"Internal error: dfs search order violated"</span></pre>where <tt>parent</tt> holds a table of parent pointers, <tt>entry</tt> a table of node states, and <tt>order</tt> the eventual topological ordering.the parent table is not updated when entering root nodes,
thus two different functions.<h3>Monad</h3>The schemer in me was pleased to spot a decent opportunity to use <tt>callCC</tt>. If a cycle is discovered, it allows the computation to
terminate immediately and also avoids the wrapping/unwarpping of some
part of the computation in <tt>Either</tt> until the very end. What was a simple <pre><span class='hs-definition'>explore</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>State</span> <span class='hs-conid'>IntSet</span> <span class='hs-layout'>(</span><span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span></pre> has morphed into <pre><span class='hs-definition'>dfs</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>MonadState</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>MonadCont</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span></pre><h3>Implementation</h3><pre>
<span class='hs-keyword'>type</span> <span class='hs-conid'>Cycle</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonEmpty</span>

<span class='hs-definition'>topSort'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>MonadState</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>MonadCont</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cycle</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>topSort'</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>callCC</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>cyclic</span> <span class='hs-keyglyph'>-&gt;</span>
  <span class='hs-keyword'>do</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>vertices</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.toDescList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>adjacencyIntMap</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>adjacent</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toDescList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>postIntSet</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>dfsRoot</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nodeState</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enterRoot</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>x</span>
           <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
         <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span>
                   <span class='hs-varid'>nodeState</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
                     <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enter</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>y</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cyclic</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>.</span> <span class='hs-varid'>retrace</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>=&lt;&lt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>parent</span>
     <span class='hs-varid'>forM_</span> <span class='hs-varid'>vertices</span> <span class='hs-varid'>dfsRoot</span>
     <span class='hs-conid'>Right</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>order</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>retrace</span> <span class='hs-varid'>curr</span> <span class='hs-varid'>head</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
      <span class='hs-varid'>aux</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>head</span> <span class='hs-varop'>==</span> <span class='hs-varid'>curr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span>
        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>parent</span> <span class='hs-conid'>IntMap</span><span class='hs-varop'>.!</span> <span class='hs-varid'>curr</span> <span class='hs-varop'>&lt;|</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span></pre></body></html>