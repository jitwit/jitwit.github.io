<html><head><link rel='stylesheet' type='text/css' href='css/style.css'/><link rel='stylesheet' type='text/css' href='css/haskell.css'/><meta charset='UTF-8'/><title>DFS Alga</title></head><body><h1>Expressing graph searches in haskell</h1><p><section>Recently, I helped contribute to <a href='https://github.com/snowleopard/alga'>alga</a>, a cool haskell library for working with graphs developed by
Andrey Mokhov. My first contribution implemented breadth first
search. The second took ideas from the first to improve the existing
implementations of depth first search and topological sort. This post
describes the implementations and demonstrates how haskell lends
itself well to the expression of these classic algorithms.</section></p><h2>Background</h2><h3>alga</h3><p><section>With alga, graphs are constructed using a handful of building
blocks--from empty graphs, vertices, overlays, and
connections. Overlays union the vertex and edge sets of
graphs. Connections do the same, but include edges from each vertex of
one to each vertex of the other. The expressions thus formed may later
be instantiated to an appropriate representation for further
processing. Here is the core data type used for this algebraic
framework: <pre><span class='hs-keyword'>data</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Vertex</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Overlay</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Connect</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span></pre>Two of the standard representations for directed graphs use
staple datastructures from <a href='http://hackage.haskell.org/package/containers'>containers</a>, <tt>Data.Map a (Data.Set a)</tt> and <tt>Data.IntMap Data.IntSet</tt>. Conversion to these representations (and others) is done by
specifying the appropriate fold over the interface of the graph data
type, eg:</section></p><pre>
<span class='hs-keyword'>newtype</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-layout'>{</span> <span class='hs-varid'>adjacencyIntMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap</span> <span class='hs-conid'>IntSet</span> <span class='hs-layout'>}</span>

<span class='hs-definition'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AdjacencyIntMap</span> 
<span class='hs-definition'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-conid'>IntMap.empty</span>

<span class='hs-definition'>vertex</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
<span class='hs-definition'>vertex</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.singleton</span> <span class='hs-varid'>x</span> <span class='hs-conid'>IntSet.empty</span>

<span class='hs-definition'>overlay</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
<span class='hs-definition'>overlay</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.unionWith</span> <span class='hs-conid'>IntSet.union</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>

<span class='hs-definition'>connect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
<span class='hs-definition'>connect</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.unionsWith</span> <span class='hs-conid'>IntSet.union</span>
    <span class='hs-keyglyph'>[</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-conid'>IntMap.fromSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.keysSet</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.keysSet</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>

<span class='hs-definition'>toAdjacencyIntMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ToVertex</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
<span class='hs-definition'>toAdjacencyIntMap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldg</span> <span class='hs-varid'>empty</span> <span class='hs-varid'>vertex</span> <span class='hs-varid'>overlay</span> <span class='hs-varid'>connect</span></pre><p><section>Of course, there is much more to alga. The above hopefully gives
an idea of the library's algebra, the expression-oriented approach to
construction of graphs, and the interface used for processing
them. Alga also provides means for working with undirected graphs,
relations, acyclic graphs, bipartite graphs, and so on. For more detailed information about alga, its design, and its
laws, I'd suggest checking out any of the following:  a series of <a href='https://github.com/snowleopard/alga#blog-posts'>blog posts</a>, <a href='https://www.youtube.com/watch?v=EdQGLewU-8k'>this talk</a>, <a href='https://eprint.ncl.ac.uk/file_store/production/239461/EF82F5FE-66E3-4F64-A1AC-A366D1961738.pdf'>this paper</a> or the <a href='http://hackage.haskell.org/package/algebraic-graphs'>documentation</a>.</section></p><h3>Previously</h3><p><section>There is a lot of power that comes from the above design. For any data type <tt>g</tt> with a <tt>ToGraph g</tt> instance, alga is able to use existing code from <a href='http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html'>Data.Graph</a> simply by defining conversions between a few
representations. For example, here is enough glue to unlock existing
capabilites for graphs with <tt>Ord (ToVertex g)</tt> vertices: </section></p><pre>
<span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Algebra.Graph.AdjacencyMap</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>AM</span>
<span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Graph</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>KL</span>

<span class='hs-definition'>fromAdjacencyMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyMap</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>GraphKL</span> <span class='hs-varid'>a</span>
<span class='hs-definition'>fromAdjacencyMap</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM.AM</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GraphKL</span>
    <span class='hs-layout'>{</span> <span class='hs-varid'>toGraphKL</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span>
    <span class='hs-layout'>,</span> <span class='hs-varid'>fromVertexKL</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>u</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>r</span> <span class='hs-varid'>u</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>v</span>
    <span class='hs-layout'>,</span> <span class='hs-varid'>toVertexKL</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span> <span class='hs-layout'>}</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-layout'>(</span><span class='hs-varid'>g</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>KL.graphFromEdges</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-conid'>()</span><span class='hs-layout'>,</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-conid'>Set.toAscList</span> <span class='hs-varid'>us</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>us</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>Map.toAscList</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>]</span></pre><p><section><tt>Data.Graph</tt> provides good performance for the functions it does export,
since it works on adjacency maps represented as <tt>Array Int [Int]</tt>. Unfortunately, the array-based representation does not play
well with alga's algebraic coneception of graphs. For arbitrary <tt>ToGraph g</tt>'s the result is three passes converting representations: <ul><li><tt>g</tt> -&gt; <tt>AdjacencyMap a</tt></li><li><tt>AdjacencyMap a</tt> -&gt; <tt>GraphKL a</tt></li><li><tt>Forest Int</tt> -&gt; <tt>Forest a</tt>  (in the case of <tt>dfs</tt>)</li></ul></section></p>The new implementation is basically a response to the question,
would it be better to avoid conversion by operating on adjacency maps directly?<h2>Depth First Search</h2>Here is the new implementation in its entirety:<pre>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalState</span> <span class='hs-layout'>(</span><span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-conid'>IntSet.empty</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
    <span class='hs-conid'>True</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
    <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
  <span class='hs-varid'>explore</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
  <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toList</span> <span class='hs-layout'>(</span><span class='hs-varid'>postIntSet</span> <span class='hs-varid'>v</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>new</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-conid'>IntSet.member</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>when</span> <span class='hs-varid'>new</span> <span class='hs-varop'>$</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntSet.insert</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>return</span> <span class='hs-varid'>new</span></pre>The goal is to compute a search <tt>Forest</tt> from the input vertices. It is necessary to track which vertices
have already been visited and nothing more. So, an <tt>IntSet</tt> suffices, where membership of a vertex indicates that it's tree
has been explored. Here is a bottom-up explanation of the implementation:<ul><li><tt>adjacent v</tt> exists because it's more pleasant to read than <tt>IntSet.toList (postIntSet v g)</tt>.</li><li><tt>discovered v</tt> reports if the vertex has been discovered and marks it as
such when new.</li><li><tt>walk v</tt> includes the tree from <tt>v</tt> in the forest by exploring <tt>v</tt>'s neighbors.</li><li><tt>explore vs</tt> builds a forest from all unprocessed vertices in <tt>vs</tt>.</li><li><tt>evalState (explore vs) IntSet.empty</tt> computes the forest from <tt>vs</tt>. The venerable state monad is used to thread the set of
discovered vertices through the computation, driven by the mutually
recursive <tt>walk</tt> and <tt>expore</tt>.</li></ul><tt>dfsForestFrom'</tt> has the tick ' because it is a function internal to the module. The following
three functions are exported, matching the original API from <tt>Data.Graph</tt>:<pre>
<span class='hs-definition'>dfsForest</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForest</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfsForestFrom'</span> <span class='hs-layout'>(</span><span class='hs-varid'>vertexList</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-varid'>g</span>

<span class='hs-definition'>dfsForestFrom</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForestFrom</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfsForestFrom'</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>vs</span><span class='hs-layout'>,</span> <span class='hs-varid'>hasVertex</span> <span class='hs-varid'>v</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>]</span> <span class='hs-varid'>g</span>

<span class='hs-definition'>dfs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
<span class='hs-definition'>dfs</span> <span class='hs-varid'>vs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfsForestFrom</span> <span class='hs-varid'>vs</span> <span class='hs-varop'>&gt;=&gt;</span> <span class='hs-varid'>flatten</span></pre><h2>Topological Sort</h2>The goals for implementing topological sort are loftier than
those for dfs. Besides returning a valid topological ordering of the
vertices, we want to produce the lexicographically smallest
enumeration (addressing an old <a href='https://github.com/snowleopard/alga/issues/2'>issue</a>) or produce a cycle if there is one. These increased demands are
reflected in various ways in the implementation; more state is
threaded, a hairier monad is requested, and the compactness of dfs is
gone. All in all, it's more interesting.<h3>State</h3>In order to produce a cycle, we need to keep track of parent
pointers, as well as if a vertex has been fully processed, or if its
descendents are currently being expanded. Also, root vertices don't
have parents, so their state must be entered differently. The state
representation used is then:<pre>
<span class='hs-keyword'>data</span> <span class='hs-conid'>NodeState</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Exited</span>
<span class='hs-keyword'>data</span> <span class='hs-conid'>S</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>S</span> <span class='hs-layout'>{</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>Int</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>entry</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>NodeState</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>order</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>

<span class='hs-comment'>-- state query/manipulation</span>
<span class='hs-definition'>nodeState</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.lookup</span> <span class='hs-varid'>v</span> <span class='hs-varop'>.</span> <span class='hs-varid'>entry</span><span class='hs-layout'>)</span>
<span class='hs-definition'>enterRoot</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>
<span class='hs-definition'>enter</span> <span class='hs-varid'>u</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-varid'>u</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
                                      <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
                                      <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>
<span class='hs-definition'>exit</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.alter</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>leave</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
  <span class='hs-keyword'>where</span> <span class='hs-varid'>leave</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
          <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exited</span>
          <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"Internal error: dfs search order violated"</span></pre><ul>Brief remarks<li><tt>parent</tt> holds a table of parent pointers, <tt>entry</tt> a table of node states, and <tt>order</tt> the eventual topological ordering.</li><li>the parent table is not updated when entering root nodes,
thus two different functions.</li></ul><h3>Monad</h3><pre>
<span class='hs-keyword'>type</span> <span class='hs-conid'>Cycle</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonEmpty</span>

<span class='hs-definition'>topSort'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>MonadState</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>MonadCont</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cycle</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>topSort'</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>callCC</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>cyclic</span> <span class='hs-keyglyph'>-&gt;</span>
  <span class='hs-keyword'>do</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>vertices</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.toDescList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>adjacencyIntMap</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>adjacent</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toDescList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>postIntSet</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>dfsRoot</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nodeState</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enterRoot</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>x</span>
           <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
         <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span>
                   <span class='hs-varid'>nodeState</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
                     <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enter</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>y</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cyclic</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>.</span> <span class='hs-varid'>retrace</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>=&lt;&lt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>parent</span>
     <span class='hs-varid'>forM_</span> <span class='hs-varid'>vertices</span> <span class='hs-varid'>dfsRoot</span>
     <span class='hs-conid'>Right</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>order</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>retrace</span> <span class='hs-varid'>curr</span> <span class='hs-varid'>head</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
      <span class='hs-varid'>aux</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>head</span> <span class='hs-varop'>==</span> <span class='hs-varid'>curr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span>
        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>parent</span> <span class='hs-conid'>IntMap</span><span class='hs-varop'>.!</span> <span class='hs-varid'>curr</span> <span class='hs-varop'>&lt;|</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span></pre></body></html>