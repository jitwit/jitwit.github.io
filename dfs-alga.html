<html><head><link rel='stylesheet' type='text/css' href='css/haskell.css'/><meta charset='UTF-8'/><title>DFS Alga</title></head><body><h1>Expressing graph searches in haskell</h1><p><section>Recently, I helped contribute to <a href='https://github.com/snowleopard/alga'>alga</a>, a fun haskell library for working with graphs developed by
Andrey Mokhov. My first contribution implemented breadth first
search. The second took ideas from the first to improve the existing
implementations of depth first search and topological sort. This post
describes the implementations and how haskell lends itself well to the
expression of these classic algorithms.</section></p><h2>Background on alga</h2><p><section>With alga, graphs are constructed using a handful of building
blocks---from empty graphs, vertices, overlays, and
connections. Overlays union the vertex and edge sets of
graphs. Connections do the same, but include edges from each vertex of
one to each vertex of the other. The expressions thus formed may later
be instantiated to an appropriate representation for further
processing. Here is the core data type used for this algebraic
framework: <pre><span class='hs-keyword'>data</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Empty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Vertex</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Overlay</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Connect</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span></pre>Two of the standard representations for directed graphs use
staple datastructures from <a href='http://hackage.haskell.org/package/containers-0.6.2.1'>containers</a>, <tt>Data.Map a (Data.Set a)</tt> and <tt>Data.IntMap Data.IntSet</tt>. Conversion to these representations (and others) is done by
specifying the appropriate fold over the interface of the graph data
type, eg:</section></p><pre>
<span class='hs-keyword'>newtype</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-layout'>{</span> <span class='hs-varid'>adjacencyIntMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap</span> <span class='hs-conid'>IntSet</span> <span class='hs-layout'>}</span>

<span class='hs-definition'>empty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AdjacencyIntMap</span> 
<span class='hs-definition'>empty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-conid'>IntMap.empty</span>

<span class='hs-definition'>vertex</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
<span class='hs-definition'>vertex</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.singleton</span> <span class='hs-varid'>x</span> <span class='hs-conid'>IntSet.empty</span>

<span class='hs-definition'>overlay</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
<span class='hs-definition'>overlay</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.unionWith</span> <span class='hs-conid'>IntSet.union</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>

<span class='hs-definition'>connect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
<span class='hs-definition'>connect</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AM</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AM</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.unionsWith</span> <span class='hs-conid'>IntSet.union</span>
    <span class='hs-keyglyph'>[</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>,</span> <span class='hs-conid'>IntMap.fromSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.keysSet</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.keysSet</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>

<span class='hs-definition'>toAdjacencyIntMap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ToVertex</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>~</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span>
<span class='hs-definition'>toAdjacencyIntMap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldg</span> <span class='hs-varid'>empty</span> <span class='hs-varid'>vertex</span> <span class='hs-varid'>overlay</span> <span class='hs-varid'>connect</span></pre><p><section>There is of course much more to alga. The above merely gives an
idea of the library's algebra, the expression-oriented approach to
construction of graphs, and the interface used for processing
them. Alga also provides means for working with undirected graphs,
relations, acyclic graphs, bipartite graphs, and so on. More information about alga, its design, and its laws may be
found in its <a href='http://hackage.haskell.org/package/algebraic-graphs'>documentation</a>, a series of <a href='https://github.com/snowleopard/alga#blog-posts'>blog posts</a>, and in <a href='https://www.youtube.com/watch?v=EdQGLewU-8k'>this talk</a>.</section></p><h2>Depth First Search</h2>Now the new implementation.<h3>Previously</h3>There is a lot of power that comes from using the <a href='http://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html'>Data.Graph</a> to take advantage of existing the dfs implementation.<pre>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Forest</span> <span class='hs-conid'>Int</span>
<span class='hs-definition'>dfsForestFrom'</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalState</span> <span class='hs-layout'>(</span><span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-conid'>IntSet.empty</span> <span class='hs-keyword'>where</span>
  <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
    <span class='hs-conid'>True</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
    <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-varid'>vs</span>
  <span class='hs-varid'>explore</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
  <span class='hs-varid'>walk</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>explore</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>adjacent</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toList</span> <span class='hs-layout'>(</span><span class='hs-varid'>postIntSet</span> <span class='hs-varid'>v</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>discovered</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>new</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-conid'>IntSet.member</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>when</span> <span class='hs-varid'>new</span> <span class='hs-varop'>$</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntSet.insert</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
                    <span class='hs-varid'>return</span> <span class='hs-varid'>new</span></pre><h2>Topological Sort</h2><pre>
<span class='hs-keyword'>type</span> <span class='hs-conid'>Cycle</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonEmpty</span>
<span class='hs-keyword'>data</span> <span class='hs-conid'>NodeState</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Exited</span>
<span class='hs-keyword'>data</span> <span class='hs-conid'>S</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>S</span> <span class='hs-layout'>{</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>Int</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>entry</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IntMap.IntMap</span> <span class='hs-conid'>NodeState</span>
           <span class='hs-layout'>,</span> <span class='hs-varid'>order</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>

<span class='hs-definition'>topSort'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>MonadState</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>MonadCont</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
         <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>AdjacencyIntMap</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cycle</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class='hs-definition'>topSort'</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>callCC</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>cyclic</span> <span class='hs-keyglyph'>-&gt;</span>
  <span class='hs-keyword'>do</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>vertices</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-conid'>IntMap.toDescList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>adjacencyIntMap</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>adjacent</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IntSet.toDescList</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-varid'>postIntSet</span> <span class='hs-varid'>g</span>
         <span class='hs-varid'>dfsRoot</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nodeState</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enterRoot</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>x</span>
           <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
         <span class='hs-varid'>dfs</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>adjacent</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span>
                   <span class='hs-varid'>nodeState</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
                     <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>enter</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>dfs</span> <span class='hs-varid'>y</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>exit</span> <span class='hs-varid'>y</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
                     <span class='hs-conid'>Just</span> <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cyclic</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>.</span> <span class='hs-varid'>retrace</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-varop'>=&lt;&lt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>parent</span>
     <span class='hs-varid'>forM_</span> <span class='hs-varid'>vertices</span> <span class='hs-varid'>dfsRoot</span>
     <span class='hs-conid'>Right</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>gets</span> <span class='hs-varid'>order</span>
  <span class='hs-keyword'>where</span>
    <span class='hs-varid'>nodeState</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gets</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.lookup</span> <span class='hs-varid'>v</span> <span class='hs-varop'>.</span> <span class='hs-varid'>entry</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>enter</span> <span class='hs-varid'>u</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-varid'>u</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
                                          <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
                                          <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>enterRoot</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.insert</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Entered</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span>
    <span class='hs-varid'>exit</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modify'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-conid'>IntMap.alter</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>leave</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
      <span class='hs-keyword'>where</span> <span class='hs-varid'>leave</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>case</span>
              <span class='hs-conid'>Entered</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Exited</span>
              <span class='hs-conid'>Exited</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"Internal error: dfs search order violated"</span>
    <span class='hs-varid'>retrace</span> <span class='hs-varid'>curr</span> <span class='hs-varid'>head</span> <span class='hs-varid'>parent</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
      <span class='hs-varid'>aux</span> <span class='hs-varid'>xs</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>head</span> <span class='hs-varop'>==</span> <span class='hs-varid'>curr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span>
        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>aux</span> <span class='hs-layout'>(</span><span class='hs-varid'>parent</span> <span class='hs-conid'>IntMap</span><span class='hs-varop'>.!</span> <span class='hs-varid'>curr</span> <span class='hs-varop'>&lt;|</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span></pre></body></html>